# Дано

Нам дан [скрипт](../deploy/main.py) на питоне, подвешенный на сокате, который принимает файл в `base64` кодировке, пишет его в `kek.rs` и запускает команду `cargo run`. Эта комманда запускает проэкт на расте, состоящий из 2 частей: `proc_macro` которое проверяет что файл в `kek.rs` не использует никаких вызовов кроме тех, что содержатся в rust `prelude`, и не исполняет макросов кроме `print`, `println` и `vec`, и вставляет этот файл; и главного файл, который лишь применяет этот макрос. От нас требуется прочитать файл со случайным названием.

# Отсупление про макросы в расте

Макросы в расте, а конкретно `proc_macro`, это такие функции которые исполняются при компиляции. Они принимают на вход и возращают поток токенов (репрезентацию даннных компилятора). По сути они позволяют модифицировать код, превращая его в произвольный компилируемый код (к которому применяются все те же ограничения вроде lifetime и unsafe). В нашем случае происходить проверка на вызов только разрешенных макросов, функций и полный запрет unsafe, затем возращается тот же код. (гонка не возможна, потому что мы вставляет уже проверенный код, не читая из файла дважды).

# Как будем действовать

В языке rust накладываются строгие ограничения на код, которые не позволяют нам просто так написать на стек роп. В частности существует так называемый `borrow checker`, который проверяет что время жизни (далее lifetime) обьекта не превышает время жизни обьектов от которых он зависим, в частности время жизни ссылки на обьект не превышает время жизни самого обьекта. Именно это ограничение мы и будем обходить, чтобы получить исполнение произвольного кода с помощью [техники](https://github.com/Speykious/cve-rs/blob/main/src/lifetime_expansion.rs). Сама техника основано на баге компилятора, про нее можно прочитать в комментариях в соотвествующем файле. По сути она позволяет продлить lifetime любого обьекта до `'static` (статического "бесконечного" лайфайтам). Существует много разных способо использования этой техники для получения rce, мы раскажем лишь про один (возможно самый простой) из них.

# Heap leak, arbitrary read/write

Идея в том что мы получим один вектор у которого данные освобождены и указывают на другой вектор лежащий на хипе. Таким образом мы сможем прочитать (получая лик хипы) или записать указатель второго вектора (получая arbitrary read/write). Требуется получить вектор с `capacity == size` размера структуры вектора `std::mem::size_of::<Vec<u8>>() == 24`. Проще всего этого достигнуть использую вектор с элементом размера `3` (`Vec<[u8; 3]>`). Поскольку вектор [амортизированно](https://doc.rust-lang.org/src/alloc/raw_vec/mod.rs.html#571) растет [2 раза](https://doc.rust-lang.org/src/alloc/raw_vec/mod.rs.html#659), начиная с `1`, добавив 8 раз элемент в такой вектор получим вектор с размером буфера 24 байта. Затем аллоцируем вектор на хипе: сделаем вектор векторов из одного элемента (`vec![vec![1337u64]]`).
```rust
let v = {
    // создаем вектор со статическим lifetime с размером буфера 24 байт
    let mut a = vec![];
    for _ in 0..8 {
        a.push([0u8; 3]);
    }
    let r = &mut a;
    expand_mut(r)
};

// вектор векторов на хипе
let mut vv = vec![vec![1337u64]];
```

Чтобы прочитать получить адрес буфера прочитаем полученные экспериментальным путем 8 байт начиная с 8 и чтобы запизать аналогично. Прочитав адрес буфера получаем некий адрес на хипе. Теперь можем записав произвольный адрес в буфер и записать/прочитать в/из них число, получая arbitrary read/write.

# Стандартный взлом

В дебагаер пройдемся по хипе в поисках адресов либцы. Лично я нашел адрес по оффсету `0x1e84e0`. Соотвественно поскольку хипа можем быть не детерминированно после перекомпиляций, пройдемся по хипе в нашем эксплоите в поисках адреса который соотвествует данному. Прочитав его получим лик либцы. Из либцы считаем стек через `environ` (оффсет стека уже детерменирован и не зависит от компиляции). На стек запишем роп `system("/bin/sh")` и получим rce.
